name: ðŸš€ New Release Preparation

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: "Type de release"
        required: true
        default: "minor"
        type: choice
        options:
          - patch
          - minor
          - major
      pre_release:
        description: "Pre-release (alpha, beta, rc)"
        required: false
        type: string

env:
  REGISTRY: ghcr.io
  REPO_NAME_LOWER: ${{ format('{0}', github.event.repository.name) }}
  IMAGE_NAME_SERVER: ${{ github.repository_owner }}/proxyauthk8s/server
  IMAGE_NAME_FRONT: ${{ github.repository_owner }}/proxyauthk8s/front
  NODE_VERSION: "24"
  RUST_VERSION: "1.91"

jobs:
  prepare-release:
    name: ðŸ“‹ Prepare Release Information
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.version.outputs.new_version }}
      branch_name: ${{ steps.branch.outputs.branch_name }}
      release_name: ${{ steps.release_info.outputs.release_name }}
    steps:
      - name: ðŸ” Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: package-lock.json

      - name: ðŸ” Debug npm environment
        run: |
          echo "Node version: $(node --version)"
          echo "NPM version: $(npm --version)"
          echo "Package-lock exists: $(test -f package-lock.json && echo 'yes' || echo 'no')"
          ls -la package*.json

      - name: ðŸ”§ Install dependencies
        run: |
          yarn install --frozen-lockfile
        env:
          NODE_ENV: production

      - name: ðŸ“ˆ Calculate new version
        id: version
        run: |
          current_version=$(node -p "require('./package.json').version")
          echo "Current version: $current_version"

          # Increment version based on input
          case "${{ github.event.inputs.release_type }}" in
            "major")
              new_version=$(npm version major --no-git-tag-version | sed 's/v//')
              ;;
            "minor")
              new_version=$(npm version minor --no-git-tag-version | sed 's/v//')
              ;;
            "patch")
              new_version=$(npm version patch --no-git-tag-version | sed 's/v//')
              ;;
          esac

          # Add pre-release suffix if specified
          if [ -n "${{ github.event.inputs.pre_release }}" ]; then
            new_version="${new_version}-${{ github.event.inputs.pre_release }}"
          fi

          echo "New version: $new_version"
          echo "new_version=$new_version" >> $GITHUB_OUTPUT

          # Reset package.json to avoid commit issues
          git checkout -- package.json

      - name: ðŸŒ¿ Create branch name
        id: branch
        run: |
          branch_name="NR/release-v${{ steps.version.outputs.new_version }}"
          echo "branch_name=$branch_name" >> $GITHUB_OUTPUT

      - name: ðŸ“ Generate release name
        id: release_info
        run: |
          release_name="Release v${{ steps.version.outputs.new_version }}"
          echo "release_name=$release_name" >> $GITHUB_OUTPUT

  create-release-branch:
    name: ðŸŒ¿ Create Release Branch
    runs-on: ubuntu-latest
    needs: prepare-release
    steps:
      - name: ðŸ” Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ”§ Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: ðŸŒ¿ Create and push release branch
        run: |
          git checkout -b "${{ needs.prepare-release.outputs.branch_name }}"
          git push -u origin "${{ needs.prepare-release.outputs.branch_name }}"

  code-quality-validation:
    name: ðŸ” Code Quality Validation
    runs-on: ubuntu-latest
    needs: [prepare-release, create-release-branch]
    outputs:
      backend_quality: ${{ steps.backend_check.outputs.status }}
      frontend_quality: ${{ steps.frontend_check.outputs.status }}
    steps:
      - name: ðŸ” Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.branch_name }}

      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"
          cache-dependency-path: package-lock.json

      - name: ðŸ¦€ Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}
          components: clippy, rustfmt

      - name: ðŸ”§ Install dependencies
        run: |
          yarn install --frozen-lockfile
        env:
          NODE_ENV: production

      - name: ðŸ” Backend Quality Check
        id: backend_check
        run: |
          echo "## ðŸ¦€ Backend Quality Report" >> quality_report.md

          # Rust formatting check
          if cargo fmt -- --check; then
            echo "âœ… Rust code formatting is correct" >> quality_report.md
          else
            echo "âŒ Rust code formatting issues found" >> quality_report.md
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Rust clippy check
          if cargo clippy --all-targets --all-features -- -D warnings; then
            echo "âœ… Rust clippy checks passed" >> quality_report.md
          else
            echo "âŒ Rust clippy issues found" >> quality_report.md
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Rust tests
          if cargo test; then
            echo "âœ… Rust tests passed" >> quality_report.md
          else
            echo "âŒ Rust tests failed" >> quality_report.md
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "status=success" >> $GITHUB_OUTPUT

      - name: ðŸ” Frontend Quality Check
        id: frontend_check
        run: |
          echo "## ðŸŒ Frontend Quality Report" >> quality_report.md
          yarn install

          # TypeScript compilation
          if yarn build; then
            echo "âœ… TypeScript compilation successful" >> quality_report.md
          else
            echo "âŒ TypeScript compilation failed" >> quality_report.md
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Linting
          if yarn nx lint front; then
            echo "âœ… Frontend linting passed" >> quality_report.md
          else
            echo "âŒ Frontend linting issues found" >> quality_report.md
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

          echo "status=success" >> $GITHUB_OUTPUT

      - name: ðŸ“¤ Upload Quality Report
        uses: actions/upload-artifact@v4
        with:
          name: quality-report
          path: quality_report.md

  changelog-generation:
    name: ðŸ“ Generate Changelog
    runs-on: ubuntu-latest
    needs: [prepare-release, create-release-branch]
    steps:
      - name: ðŸ” Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.branch_name }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: ðŸ”§ Install changelog generator
        run: npm install -g conventional-changelog-cli

      - name: ðŸ“ Generate changelog
        run: |
          NEW_VERSION="${{ needs.prepare-release.outputs.new_version }}"

          # Generate changelog for this version
          conventional-changelog -p angular -i CHANGELOG.md -s -r 0

          # Create version-specific changelog
          echo "# Changelog for v$NEW_VERSION" > "CHANGELOG-v$NEW_VERSION.md"
          echo "" >> "CHANGELOG-v$NEW_VERSION.md"
          conventional-changelog -p angular -r 1 >> "CHANGELOG-v$NEW_VERSION.md"

      - name: ðŸ”§ Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: ðŸ“ Generate Release Guide and Commit
        run: |
          NEW_VERSION="${{ needs.prepare-release.outputs.new_version }}"
          BRANCH_NAME="${{ needs.prepare-release.outputs.branch_name }}"

          # Generate release guide
          cat > "RELEASE-GUIDE-v$NEW_VERSION.md" << EOF
          # ðŸš€ Release Guide for v$NEW_VERSION

          ## ðŸ“‹ How to Upgrade the Release Branch

          ### ðŸ”„ Sync with Latest Changes
          \`\`\`bash
          # Switch to the release branch
          git checkout $BRANCH_NAME

          # Pull latest changes from remote
          git pull origin $BRANCH_NAME

          # Merge latest changes from main (if needed)
          git merge origin/main

          # Push updated branch
          git push origin $BRANCH_NAME
          \`\`\`

          ### ðŸ”§ Manual Version Updates (if needed)
          \`\`\`bash
          # Update package.json version manually
          npm version $NEW_VERSION --no-git-tag-version

          # Update all Cargo.toml files
          find . -name "Cargo.toml" -not -path "./target/*" -exec sed -i 's/^version = ".*"/version = "$NEW_VERSION"/' {} \\;

          # Update frontend package.json files
          find apps libs -name "package.json" -exec jq '.version = "$NEW_VERSION"' {} \\; > tmp && mv tmp {}

          # Commit version changes
          git add .
          git commit -m "chore: manual version bump to v$NEW_VERSION"
          git push origin $BRANCH_NAME
          \`\`\`

          ## âœï¸ How to Sign All Commits in the Branch

          ### ðŸ”‘ Setup GPG Signing (First Time)
          \`\`\`bash
          # Generate a new GPG key (if you don't have one)
          gpg --full-generate-key

          # List your GPG keys and copy the key ID
          gpg --list-secret-keys --keyid-format=long

          # Configure git to use your GPG key
          git config --global user.signingkey YOUR_KEY_ID
          git config --global commit.gpgsign true

          # Export your public key and add it to GitHub
          gpg --armor --export YOUR_KEY_ID
          \`\`\`

          ### ðŸ“ Sign Commits Retroactively
          \`\`\`bash
          # Switch to release branch
          git checkout $BRANCH_NAME

          # Interactive rebase to sign all commits since main
          git rebase --exec 'git commit --amend --no-edit -S' origin/main

          # Alternative: Sign specific range of commits
          git rebase -i --exec 'git commit --amend --no-edit -S' HEAD~N  # N = number of commits

          # Force push the signed commits (âš ï¸ Use with caution)
          git push --force-with-lease origin $BRANCH_NAME
          \`\`\`

          ### ðŸ”’ Sign Individual New Commits
          \`\`\`bash
          # Enable signing for current repository
          git config commit.gpgsign true

          # Make a signed commit
          git commit -S -m "feat: your commit message"

          # Verify commit is signed
          git log --show-signature -1
          \`\`\`

          ## ðŸ› ï¸ Troubleshooting

          ### ðŸ” Common Issues

          #### GPG Key Not Found
          \`\`\`bash
          # Check if GPG is working
          gpg --version

          # List available keys
          gpg --list-keys

          # Test GPG signing
          echo "test" | gpg --clearsign
          \`\`\`

          #### Merge Conflicts During Upgrade
          \`\`\`bash
          # Abort current merge
          git merge --abort

          # Try merge with strategy
          git merge -X ours origin/main  # Prefer release branch changes
          # OR
          git merge -X theirs origin/main  # Prefer main branch changes

          # Manual conflict resolution
          git mergetool
          git commit -m "resolve: merge conflicts with main"
          \`\`\`

          #### Force Push Safety
          \`\`\`bash
          # Always use force-with-lease instead of force
          git push --force-with-lease origin $BRANCH_NAME

          # Check what will be pushed before forcing
          git log origin/$BRANCH_NAME..HEAD --oneline
          \`\`\`

          ## ðŸ“Š Quality Checks

          ### âœ… Pre-Push Validation
          \`\`\`bash
          # Run local quality checks
          cargo fmt --check
          cargo clippy --all-targets --all-features
          cargo test
          yarn lint
          yarn build

          # Check commit messages format
          cog check --from-latest-tag

          # Verify all commits are signed
          git log --pretty="format:%h %G? %s" origin/main..HEAD
          # Look for 'G' (good signature) or 'U' (unknown signature)
          \`\`\`

          ### ðŸ”„ Update Reports
          After making changes to the release branch, the \`update-release-reports.yml\` workflow will automatically:
          - ðŸ” Re-run quality checks
          - ðŸ”’ Update security audits
          - ðŸ³ Rebuild Docker images
          - ðŸ’¬ Update PR comments with latest status

          ## ðŸŽ¯ Final Steps

          1. âœ… Ensure all CI checks pass
          2. ðŸ” Review PR description and reports
          3. ðŸ‘¥ Request code review from team
          4. ðŸš€ Merge PR when approved
          5. ðŸ·ï¸ Create GitHub release from merged commit
          6. ðŸ“¢ Announce release to stakeholders
          EOF

          # Only commit the main CHANGELOG.md to repository
          git add CHANGELOG.md
          git commit -m "docs: update changelog for v${{ needs.prepare-release.outputs.new_version }}"
          git push origin "${{ needs.prepare-release.outputs.branch_name }}"

          echo "ðŸ“‹ Changelog and release guide generated for artifacts only - not committed to repository"

      - name: ðŸ“¤ Upload Changelog and Guide
        uses: actions/upload-artifact@v4
        with:
          name: changelog
          path: |
            CHANGELOG-v*.md
            RELEASE-GUIDE-v*.md

  security-audit:
    name: ðŸ”’ Security & Dependencies Audit
    runs-on: ubuntu-latest
    needs: [prepare-release, create-release-branch]
    outputs:
      audit_status: ${{ steps.audit.outputs.status }}
    steps:
      - name: ðŸ” Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.branch_name }}

      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: ðŸ¦€ Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}

      - name: ðŸ”§ Install audit tools
        run: |
          npm install -g npm-audit-resolver
          cargo install cargo-audit

      - name: ðŸ” NPM Security Audit
        id: audit
        run: |
          echo "## ðŸ”’ Security Audit Report" > security_report.md
          echo "" >> security_report.md

          # NPM Audit
          echo "### ðŸ“¦ NPM Dependencies" >> security_report.md
          if npm audit --audit-level=moderate; then
            echo "âœ… No moderate or high severity vulnerabilities found in NPM packages" >> security_report.md
          else
            echo "âŒ Security vulnerabilities found in NPM packages" >> security_report.md
            npm audit --json >> security_report.md
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

          # Cargo Audit with severity filtering
          echo "### ðŸ¦€ Rust Dependencies" >> security_report.md

          # Run cargo audit and capture JSON output
          if cargo audit --format json > cargo_audit_output.json 2>/dev/null; then
            echo "âœ… No security vulnerabilities found in Rust packages" >> security_report.md
          else
            # Parse JSON output to filter by severity > 7
            high_severity_count=$(jq -r '
              [.vulnerabilities.list[] |
               select(.advisory.cvss and (.advisory.cvss | tonumber) > 7.0)] |
              length' cargo_audit_output.json 2>/dev/null || echo "0")

            total_vulns=$(jq -r '.vulnerabilities.count // 0' cargo_audit_output.json 2>/dev/null || echo "0")

            echo "Found $total_vulns total vulnerabilities, $high_severity_count with severity > 7.0" >> security_report.md
            echo "" >> security_report.md

            # Add detailed vulnerability report
            echo "#### ðŸ” Vulnerability Details" >> security_report.md
            jq -r '.vulnerabilities.list[] |
              "- **\(.advisory.id)**: \(.advisory.title) (CVSS: \(.advisory.cvss // "N/A"))" +
              "\n  - Package: \(.package.name) v\(.package.version)" +
              "\n  - Severity: \(if .advisory.cvss and (.advisory.cvss | tonumber) > 7.0 then "ðŸ”´ HIGH" else "ðŸŸ¡ LOW/MEDIUM" end)" +
              "\n"' cargo_audit_output.json >> security_report.md 2>/dev/null || echo "- Error parsing vulnerability details" >> security_report.md

            # Only fail if high severity vulnerabilities found
            if [ "$high_severity_count" -gt 0 ]; then
              echo "âŒ $high_severity_count high-severity vulnerabilities (CVSS > 7.0) found in Rust packages" >> security_report.md
              echo "status=failed" >> $GITHUB_OUTPUT
              exit 1
            else
              echo "âœ… No high-severity vulnerabilities (CVSS > 7.0) found, but $total_vulns lower-severity issues exist" >> security_report.md
            fi
          fi

          echo "status=success" >> $GITHUB_OUTPUT

      - name: ðŸ“¤ Upload Security Report
        uses: actions/upload-artifact@v4
        with:
          name: security-report
          path: security_report.md

  commit-validation:
    name: âœ… Commit Validation
    runs-on: ubuntu-latest
    needs: [prepare-release, create-release-branch]
    outputs:
      commit_status: ${{ steps.validate.outputs.status }}
    steps:
      - name: ðŸ” Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.branch_name }}
          fetch-depth: 0

      - name: ðŸ¦€ Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}

      - name: ðŸ”§ Install Cocogitto
        run: |
          cargo install --locked cocogitto

      - name: âœ… Validate Conventional Commits with Cocogitto
        id: validate
        run: |
          echo "## âœ… Commit Validation Report" > commit_report.md
          echo "" >> commit_report.md

          echo "### ðŸ“ Cocogitto Conventional Commit Validation" >> commit_report.md
          failed=false

          # Check if any tags exist
          if git tag -l | grep -q .; then
            echo "Tags found, checking commits from latest tag..."
            cog_command="cog check --from-latest-tag"
          else
            echo "No tags found, checking all commits..."
            cog_command="cog check"
          fi

          # Run cog check to validate commits
          if $cog_command 2>&1 | tee cog_output.txt; then
            echo "âœ… All commits follow conventional commit format" >> commit_report.md
            echo "" >> commit_report.md
            echo "Command used: \`$cog_command\`" >> commit_report.md
            echo "" >> commit_report.md
            echo "\`\`\`" >> commit_report.md
            cat cog_output.txt >> commit_report.md
            echo "\`\`\`" >> commit_report.md
          else
            echo "âŒ Some commits don't follow conventional commit format" >> commit_report.md
            echo "" >> commit_report.md
            echo "Command used: \`$cog_command\`" >> commit_report.md
            echo "" >> commit_report.md
            echo "\`\`\`" >> commit_report.md
            cat cog_output.txt >> commit_report.md
            echo "\`\`\`" >> commit_report.md
            failed=true
          fi

          # Validate commit signatures
          echo "" >> commit_report.md
          echo "### âœï¸ Commit Signature Validation" >> commit_report.md
          for commit in $commits; do
            if git verify-commit $commit 2>/dev/null; then
              echo "âœ… Commit $commit is signed" >> commit_report.md
            else
              echo "âŒ Commit $commit is not signed" >> commit_report.md
              failed=true
            fi
          done

          if [ "$failed" = true ]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "status=success" >> $GITHUB_OUTPUT
          fi

      - name: ðŸ“¤ Upload Commit Report
        uses: actions/upload-artifact@v4
        with:
          name: commit-report
          path: commit_report.md

  docker-build:
    name: ðŸ³ Docker Build & SBOM Generation
    runs-on: ubuntu-latest
    needs:
      [
        prepare-release,
        code-quality-validation,
        security-audit,
        commit-validation,
      ]
    if: needs.code-quality-validation.outputs.backend_quality == 'success' && needs.code-quality-validation.outputs.frontend_quality == 'success'
    outputs:
      server_image: ${{ steps.build_server.outputs.image }}
      front_image: ${{ steps.build_front.outputs.image }}
    steps:
      - name: ðŸ” Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.branch_name }}

      - name: ðŸ”§ Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: ðŸ” Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ”§ Install Syft for SBOM generation
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

      - name: ðŸ—ï¸ Build Server Image
        id: build_server
        run: |
          IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME_SERVER }}:v${{ needs.prepare-release.outputs.new_version }}"

          docker buildx build \
            --platform linux/amd64 \
            --tag $IMAGE_TAG \
            --file deploy/build/back/Containerfile \
            --push .

          echo "image=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: ðŸ—ï¸ Build Front Image
        id: build_front
        run: |
          IMAGE_TAG="${{ env.REGISTRY }}/${{ env.IMAGE_NAME_FRONT }}:v${{ needs.prepare-release.outputs.new_version }}"

          docker buildx build \
            --platform linux/amd64 \
            --tag $IMAGE_TAG \
            --file deploy/build/front/Containerfile \
            --push .

          echo "image=$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: ðŸ“‹ Generate SBOM for Server
        run: |
          syft ${{ steps.build_server.outputs.image }} -o spdx-json=server-sbom.json
          syft ${{ steps.build_server.outputs.image }} -o table=server-sbom.txt

      - name: ðŸ“‹ Generate SBOM for Front
        run: |
          syft ${{ steps.build_front.outputs.image }} -o spdx-json=front-sbom.json
          syft ${{ steps.build_front.outputs.image }} -o table=front-sbom.txt

      - name: ðŸ“¤ Upload SBOM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: sbom-reports
          path: |
            *-sbom.json
            *-sbom.txt

  docker-security-scan:
    name: ðŸ” Docker Security Scan
    runs-on: ubuntu-latest
    needs: [prepare-release, docker-build]
    steps:
      - name: ðŸ”§ Install Grype for vulnerability scanning
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin

      - name: ðŸ” Scan Server Image for vulnerabilities
        run: |
          echo "## ðŸ³ Docker Security Scan Report" > docker_security_report.md
          echo "" >> docker_security_report.md

          echo "### ðŸ–¥ï¸ Server Image Vulnerabilities" >> docker_security_report.md
          grype ${{ needs.docker-build.outputs.server_image }} -o table >> docker_security_report.md

          echo "" >> docker_security_report.md
          echo "### ðŸŒ Frontend Image Vulnerabilities" >> docker_security_report.md
          grype ${{ needs.docker-build.outputs.front_image }} -o table >> docker_security_report.md

      - name: ðŸ“¤ Upload Docker Security Report
        uses: actions/upload-artifact@v4
        with:
          name: docker-security-report
          path: docker_security_report.md

  swagger-validation:
    name: ðŸ“‹ Swagger Generation & Validation
    runs-on: ubuntu-latest
    needs: [prepare-release, code-quality-validation]
    if: needs.code-quality-validation.outputs.backend_quality == 'success'
    steps:
      - name: ðŸ” Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.branch_name }}

      - name: ðŸ¦€ Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: ${{ env.RUST_VERSION }}

      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: ðŸ”§ Install Swagger tools
        run: |
          npm install -g swagger-jsdoc swagger2openapi @apidevtools/swagger-cli

      - name: ðŸ“‹ Generate and validate Swagger
        run: |
          echo "## ðŸ“‹ Swagger Validation Report" > swagger_report.md
          echo "" >> swagger_report.md

          # Generate swagger (assuming you have a generation script)
          if [ -f "scripts/generate-swagger.sh" ]; then
            ./scripts/generate-swagger.sh
            echo "âœ… Swagger generated successfully" >> swagger_report.md
          else
            cargo run --bin swaggergen
            echo "âœ… Swagger generated via Rust binary" >> swagger_report.md
          fi

          # Validate swagger file
          if swagger-cli validate swagger.json; then
            echo "âœ… Swagger validation passed" >> swagger_report.md
          else
            echo "âŒ Swagger validation failed" >> swagger_report.md
          fi
      - name: ðŸ“¤ Upload Swagger Report
        uses: actions/upload-artifact@v4
        with:
          name: swagger-report
          path: swagger_report.md

  helm-build:
    name: âŽˆ Helm Chart Build & OCI Package
    runs-on: ubuntu-latest
    needs: [prepare-release, code-quality-validation]
    if: needs.code-quality-validation.outputs.backend_quality == 'success'
    outputs:
      main_chart_version: ${{ steps.build_charts.outputs.main_chart_version }}
      crd_chart_version: ${{ steps.build_charts.outputs.crd_chart_version }}
      main_chart_oci: ${{ steps.build_charts.outputs.main_chart_oci }}
      crd_chart_oci: ${{ steps.build_charts.outputs.crd_chart_oci }}
    steps:
      - name: ðŸ” Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.branch_name }}

      - name: âŽˆ Install Helm
        uses: azure/setup-helm@v4
        with:
          version: "latest"

      - name: ðŸ” Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ”§ Install Helm plugins
        run: |
          helm plugin install https://github.com/chartmuseum/helm-push || true
          helm plugin install https://github.com/databus23/helm-diff || true

      - name: âŽˆ Build, validate and push Helm charts as OCI artifacts
        id: build_charts
        run: |
          echo "## âŽˆ Helm Chart Build & OCI Package Report" > helm_report.md
          echo "" >> helm_report.md

          # Create directory for packaged charts
          mkdir -p helm-packages

          NEW_VERSION="${{ needs.prepare-release.outputs.new_version }}"
          REGISTRY="${{ env.REGISTRY }}"
          REPO_OWNER="${{ github.repository_owner }}"

          # OCI registry paths
          MAIN_CHART_OCI_PATH="oci://${REGISTRY}/${REPO_OWNER}/proxyauthk8s/helm-proxyauthk8s"
          CRD_CHART_OCI_PATH="oci://${REGISTRY}/${REPO_OWNER}/proxyauthk8s/helm-proxyauthk8s-crd"

          # Update chart versions
          echo "### ðŸ“ˆ Version Updates" >> helm_report.md

          # Update main chart version
          sed -i "s/^version: .*/version: $NEW_VERSION/" deploy/chart/Chart.yaml
          sed -i "s/^appVersion: .*/appVersion: $NEW_VERSION/" deploy/chart/Chart.yaml

          # Update CRD chart version
          sed -i "s/^version: .*/version: $NEW_VERSION/" deploy/chart-crd/Chart.yaml
          sed -i "s/^appVersion: .*/appVersion: $NEW_VERSION/" deploy/chart-crd/Chart.yaml

          echo "âœ… Updated chart versions to v$NEW_VERSION" >> helm_report.md
          echo "" >> helm_report.md

          # Validate and build main chart
          echo "### ðŸ“¦ Main Chart (proxyauthk8s)" >> helm_report.md

          helm dependency build deploy/chart/

          # Lint main chart
          if helm lint deploy/chart/; then
            echo "âœ… Main chart linting passed" >> helm_report.md
          else
            echo "âŒ Main chart linting failed" >> helm_report.md
            exit 1
          fi

          # Template main chart to validate
          if helm template proxyauthk8s deploy/chart/ > /dev/null; then
            echo "âœ… Main chart templating successful" >> helm_report.md
          else
            echo "âŒ Main chart templating failed" >> helm_report.md
            exit 1
          fi

          # Push main chart as OCI artifact
          if helm push "$MAIN_CHART_FILE" "$MAIN_CHART_OCI_PATH"; then
            echo "ðŸš€ Main chart pushed as OCI artifact: ${MAIN_CHART_OCI_PATH}:${NEW_VERSION}" >> helm_report.md
          else
            echo "âŒ Main chart OCI push failed" >> helm_report.md
            exit 1
          fi

          echo "" >> helm_report.md

          # Validate and build CRD chart
          echo "### ðŸ“¦ CRD Chart (proxyauthk8s-crd)" >> helm_report.md

          helm dependency build deploy/chart-crd/

          # Lint CRD chart
          if helm lint deploy/chart-crd/; then
            echo "âœ… CRD chart linting passed" >> helm_report.md
          else
            echo "âŒ CRD chart linting failed" >> helm_report.md
            exit 1
          fi

          # Template CRD chart to validate
          if helm template proxyauthk8s-crd deploy/chart-crd/ > /dev/null; then
            echo "âœ… CRD chart templating successful" >> helm_report.md
          else
            echo "âŒ CRD chart templating failed" >> helm_report.md
            exit 1
          fi

          # Push CRD chart as OCI artifact
          if helm push "$CRD_CHART_FILE" "$CRD_CHART_OCI_PATH"; then
            echo "ðŸš€ CRD chart pushed as OCI artifact: ${CRD_CHART_OCI_PATH}:${NEW_VERSION}" >> helm_report.md
          else
            echo "âŒ CRD chart OCI push failed" >> helm_report.md
            exit 1
          fi

          echo "" >> helm_report.md

          # Generate chart documentation
          echo "### ðŸ“‹ Chart Information" >> helm_report.md
          echo "" >> helm_report.md
          echo "#### Main Chart Details" >> helm_report.md
          echo "\`\`\`yaml" >> helm_report.md
          helm show chart deploy/chart/ >> helm_report.md
          echo "\`\`\`" >> helm_report.md
          echo "" >> helm_report.md

          echo "#### CRD Chart Details" >> helm_report.md
          echo "\`\`\`yaml" >> helm_report.md
          helm show chart deploy/chart-crd/ >> helm_report.md
          echo "\`\`\`" >> helm_report.md
          echo "" >> helm_report.md

          # OCI Artifact information
          echo "### ðŸ³ OCI Artifact Information" >> helm_report.md
          echo "" >> helm_report.md
          echo "#### Installation Commands" >> helm_report.md
          echo "\`\`\`bash" >> helm_report.md
          echo "# Install CRD chart first" >> helm_report.md
          echo "helm install proxyauthk8s-crd ${CRD_CHART_OCI_PATH}:${NEW_VERSION}" >> helm_report.md
          echo "" >> helm_report.md
          echo "# Install main chart" >> helm_report.md
          echo "helm install proxyauthk8s ${MAIN_CHART_OCI_PATH}:${NEW_VERSION}" >> helm_report.md
          echo "\`\`\`" >> helm_report.md
          echo "" >> helm_report.md

          echo "#### Upgrade Commands" >> helm_report.md
          echo "\`\`\`bash" >> helm_report.md
          echo "# Upgrade CRD chart" >> helm_report.md
          echo "helm upgrade proxyauthk8s-crd ${CRD_CHART_OCI_PATH}:${NEW_VERSION}" >> helm_report.md
          echo "" >> helm_report.md
          echo "# Upgrade main chart" >> helm_report.md
          echo "helm upgrade proxyauthk8s ${MAIN_CHART_OCI_PATH}:${NEW_VERSION}" >> helm_report.md
          echo "\`\`\`" >> helm_report.md
          echo "" >> helm_report.md

          # Set outputs
          echo "main_chart_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "crd_chart_version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "main_chart_oci=${MAIN_CHART_OCI_PATH}:${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "crd_chart_oci=${CRD_CHART_OCI_PATH}:${NEW_VERSION}" >> $GITHUB_OUTPUT

          # List packaged charts
          echo "### ðŸ“¦ Local Packaged Charts" >> helm_report.md
          echo "" >> helm_report.md
          for chart in helm-packages/*.tgz; do
            if [ -f "$chart" ]; then
              chart_size=$(du -h "$chart" | cut -f1)
              echo "- ðŸ“¦ \`$(basename "$chart")\` (${chart_size})" >> helm_report.md
            fi
          done

          echo "" >> helm_report.md
          echo "### ðŸŒ Published OCI Artifacts" >> helm_report.md
          echo "" >> helm_report.md
          echo "- ðŸŽ¯ **Main Chart**: \`${MAIN_CHART_OCI_PATH}:${NEW_VERSION}\`" >> helm_report.md
          echo "- ðŸŽ¯ **CRD Chart**: \`${CRD_CHART_OCI_PATH}:${NEW_VERSION}\`" >> helm_report.md

      - name: ðŸ“¤ Upload Helm report
        uses: actions/upload-artifact@v4
        with:
          name: helm-report
          path: helm_report.md

  version-increment:
    name: ðŸ“ˆ Increment Package Versions
    runs-on: ubuntu-latest
    needs:
      - prepare-release
      - create-release-branch
      - code-quality-validation
      - changelog-generation
      - security-audit
      - commit-validation
      - docker-build
      - docker-security-scan
      - swagger-validation
      - helm-build
      - create-pull-request
    if: always() && needs.prepare-release.result == 'success'
    steps:
      - name: ðŸ” Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.branch_name }}
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: ðŸ“¦ Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: ðŸ”§ Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: ðŸ“ˆ Update package versions
        run: |
          NEW_VERSION="${{ needs.prepare-release.outputs.new_version }}"

          # Update root package.json
          npm version $NEW_VERSION --no-git-tag-version

          # Update Rust packages
          find . -name "Cargo.toml" -not -path "./target/*" | while read -r cargo_file; do
            echo "Updating $cargo_file"
            sed -i "s/^version = \".*\"/version = \"$NEW_VERSION\"/" "$cargo_file"
          done

          # Update front-end packages
          find apps libs -name "package.json" | while read -r pkg_file; do
            echo "Updating $pkg_file"
            jq --arg version "$NEW_VERSION" '.version = $version' "$pkg_file" > tmp.$$ && mv tmp.$$ "$pkg_file"
          done

          # Commit changes
          git add .
          git commit -m "chore: bump version to v$NEW_VERSION"
          git push origin "${{ needs.prepare-release.outputs.branch_name }}"

  create-pull-request:
    name: ðŸ”€ Create Release Pull Request
    runs-on: ubuntu-latest
    needs:
      - prepare-release
      - create-release-branch
      - code-quality-validation
      - changelog-generation
      - security-audit
      - commit-validation
      - docker-build
      - docker-security-scan
      - swagger-validation
      - helm-build
    if: always() && needs.prepare-release.result == 'success'
    steps:
      - name: ðŸ” Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare-release.outputs.branch_name }}

      - name: ðŸ“¥ Download all artifacts
        uses: actions/download-artifact@v4

      - name: ðŸ“ Create comprehensive PR body
        run: |
          echo "# ðŸš€ ${{ needs.prepare-release.outputs.release_name }}" > pr_body.md
          echo "" >> pr_body.md
          echo "This pull request prepares the release for version \`v${{ needs.prepare-release.outputs.new_version }}\`." >> pr_body.md
          echo "" >> pr_body.md

          echo "## ðŸ“Š Release Preparation Summary" >> pr_body.md
          echo "" >> pr_body.md
          echo "| Check | Status |" >> pr_body.md
          echo "|-------|--------|" >> pr_body.md
          echo "| ðŸ“ˆ Version Increment | âœ… Completed |" >> pr_body.md
          echo "| ðŸ” Code Quality (Backend) | ${{ needs.code-quality-validation.outputs.backend_quality == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> pr_body.md
          echo "| ðŸ” Code Quality (Frontend) | ${{ needs.code-quality-validation.outputs.frontend_quality == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> pr_body.md
          echo "| ðŸ“ Changelog | ${{ needs.changelog-generation.result == 'success' && 'âœ… Generated' || 'âŒ Failed' }} |" >> pr_body.md
          echo "| ðŸ”’ Security Audit | ${{ needs.security-audit.outputs.audit_status == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> pr_body.md
          echo "| âœ… Commit Validation | ${{ needs.commit-validation.outputs.commit_status == 'success' && 'âœ… Passed' || 'âŒ Failed' }} |" >> pr_body.md
          echo "| ðŸ³ Docker Build | ${{ needs.docker-build.result == 'success' && 'âœ… Built' || 'âŒ Failed' }} |" >> pr_body.md
          echo "| ðŸ” Docker Security | ${{ needs.docker-security-scan.result == 'success' && 'âœ… Scanned' || 'âŒ Failed' }} |" >> pr_body.md
          echo "| ðŸ“‹ Swagger Validation | ${{ needs.swagger-validation.result == 'success' && 'âœ… Validated' || 'âŒ Failed' }} |" >> pr_body.md
          echo "| âŽˆ Helm Charts | ${{ needs.helm-build.result == 'success' && 'âœ… Built & Published as OCI' || 'âŒ Failed' }} |" >> pr_body.md
          echo "" >> pr_body.md

          echo "## ðŸ“‹ Detailed Reports" >> pr_body.md
          echo "" >> pr_body.md

          # Add detailed reports from downloaded artifacts
          if [ -f "quality-report/quality_report.md" ]; then
            cat quality-report/quality_report.md >> pr_body.md
            echo "" >> pr_body.md
          fi

          if [ -f "security-report/security_report.md" ]; then
            cat security-report/security_report.md >> pr_body.md
            echo "" >> pr_body.md
          fi

          if [ -f "commit-report/commit_report.md" ]; then
            cat commit-report/commit_report.md >> pr_body.md
            echo "" >> pr_body.md
          fi

          if [ -f "docker-security-report/docker_security_report.md" ]; then
            cat docker-security-report/docker_security_report.md >> pr_body.md
            echo "" >> pr_body.md
          fi

          if [ -f "swagger-report/swagger_report.md" ]; then
            cat swagger-report/swagger_report.md >> pr_body.md
            echo "" >> pr_body.md
          fi

          if [ -f "helm-report/helm_report.md" ]; then
            cat helm-report/helm_report.md >> pr_body.md
            echo "" >> pr_body.md
          fi

          echo "## ðŸ—ï¸ Built Artifacts" >> pr_body.md
          echo "" >> pr_body.md
          echo "### Docker Images" >> pr_body.md
          echo "- ðŸ–¥ï¸ Server: \`${{ needs.docker-build.outputs.server_image }}\`" >> pr_body.md
          echo "- ðŸŒ Frontend: \`${{ needs.docker-build.outputs.front_image }}\`" >> pr_body.md
          echo "" >> pr_body.md

          echo "### âŽˆ Helm Charts (OCI Artifacts)" >> pr_body.md
          echo "- ðŸŽ¯ Main Chart: \`${{ needs.helm-build.outputs.main_chart_oci }}\`" >> pr_body.md
          echo "- ðŸŽ¯ CRD Chart: \`${{ needs.helm-build.outputs.crd_chart_oci }}\`" >> pr_body.md
          echo "- ðŸ“¦ Traditional packages available in workflow artifacts" >> pr_body.md
          echo "" >> pr_body.md
          echo "#### Installation Commands" >> pr_body.md
          echo "\`\`\`bash" >> pr_body.md
          echo "# Install CRD chart first" >> pr_body.md
          echo "helm install proxyauthk8s-crd ${{ needs.helm-build.outputs.crd_chart_oci }}" >> pr_body.md
          echo "" >> pr_body.md
          echo "# Install main chart" >> pr_body.md
          echo "helm install proxyauthk8s ${{ needs.helm-build.outputs.main_chart_oci }}" >> pr_body.md
          echo "\`\`\`" >> pr_body.md
          echo "" >> pr_body.md

          echo "### ðŸ“‹ SBOM Reports" >> pr_body.md
          echo "- Server and Frontend SBOM available in workflow artifacts" >> pr_body.md
          echo "- Download artifacts from the Actions tab to access SBOM files" >> pr_body.md
          echo "" >> pr_body.md

          # Add changelog from downloaded artifacts (not committed files)
          if [ -f "changelog/CHANGELOG-v${{ needs.prepare-release.outputs.new_version }}.md" ]; then
            echo "## ðŸ“ Changelog" >> pr_body.md
            echo "" >> pr_body.md
            cat "changelog/CHANGELOG-v${{ needs.prepare-release.outputs.new_version }}.md" >> pr_body.md
            echo "" >> pr_body.md
          fi

          # Add release guide from downloaded artifacts (not committed files)
          if [ -f "changelog/RELEASE-GUIDE-v${{ needs.prepare-release.outputs.new_version }}.md" ]; then
            echo "## ðŸ“‹ Release Management Guide" >> pr_body.md
            echo "" >> pr_body.md
            echo "<details>" >> pr_body.md
            echo "<summary>ðŸš€ Click to expand release management instructions</summary>" >> pr_body.md
            echo "" >> pr_body.md
            cat "changelog/RELEASE-GUIDE-v${{ needs.prepare-release.outputs.new_version }}.md" >> pr_body.md
            echo "" >> pr_body.md
            echo "</details>" >> pr_body.md
            echo "" >> pr_body.md
          fi

          echo "## ðŸ“Ž Workflow Artifacts" >> pr_body.md
          echo "" >> pr_body.md
          echo "All detailed reports and SBOM files are available as downloadable artifacts:" >> pr_body.md
          echo "- ðŸ“Š **Quality Report**: Code quality analysis results" >> pr_body.md
          echo "- ðŸ”’ **Security Report**: Vulnerability audit findings" >> pr_body.md
          echo "- âœ… **Commit Report**: Conventional commit validation" >> pr_body.md
          echo "- ðŸ“‹ **SBOM Reports**: Software Bill of Materials for Docker images" >> pr_body.md
          echo "- ðŸ³ **Docker Security Report**: Container vulnerability scan results" >> pr_body.md
          echo "- ðŸ“ **Swagger Report**: API documentation validation" >> pr_body.md
          echo "- âŽˆ **Helm Packages**: Traditional Helm chart packages (.tgz files)" >> pr_body.md
          echo "- ðŸ“š **Changelog**: Generated changelog and release guide" >> pr_body.md
          echo "" >> pr_body.md

      - name: ðŸ”€ Create Pull Request
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: ${{ needs.prepare-release.outputs.branch_name }}
          base: main
          title: "NR: ${{ needs.prepare-release.outputs.release_name }}"
          body-path: pr_body.md
          commit-message: "chore: prepare release ${{ needs.prepare-release.outputs.new_version }}"
          committer: "github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
          author: "github-actions[bot] <github-actions[bot]@users.noreply.github.com>"
          signoff: true
          labels: |
            release
            automated
          assignees: ${{ github.actor }}
          reviewers: ${{ github.actor }}
